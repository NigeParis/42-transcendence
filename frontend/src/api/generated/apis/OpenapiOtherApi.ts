/* tslint:disable */
/* eslint-disable */
/**
 * @fastify/swagger
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 9.6.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ChatTest200Response,
  DisableOtp200Response,
  DisableOtp401Response,
  DisableOtp500Response,
  EnableOtp200Response,
  EnableOtp401Response,
  GetUser200Response,
  GetUser403Response,
  GetUser404Response,
  GetUserUserParameter,
  GuestLogin200Response,
  GuestLogin500Response,
  Login200Response,
  Login202Response,
  Login400Response,
  LoginOtp200Response,
  LoginOtp400Response,
  LoginOtp401Response,
  LoginOtp408Response,
  LoginOtp500Response,
  LoginOtpRequest,
  LoginRequest,
  Logout200Response,
  ProviderList200Response,
  Signin200Response,
  Signin400Response,
  Signin500Response,
  StatusOtp200Response,
  StatusOtp401Response,
  StatusOtp500Response,
} from '../models/index';
import {
    ChatTest200ResponseFromJSON,
    ChatTest200ResponseToJSON,
    DisableOtp200ResponseFromJSON,
    DisableOtp200ResponseToJSON,
    DisableOtp401ResponseFromJSON,
    DisableOtp401ResponseToJSON,
    DisableOtp500ResponseFromJSON,
    DisableOtp500ResponseToJSON,
    EnableOtp200ResponseFromJSON,
    EnableOtp200ResponseToJSON,
    EnableOtp401ResponseFromJSON,
    EnableOtp401ResponseToJSON,
    GetUser200ResponseFromJSON,
    GetUser200ResponseToJSON,
    GetUser403ResponseFromJSON,
    GetUser403ResponseToJSON,
    GetUser404ResponseFromJSON,
    GetUser404ResponseToJSON,
    GetUserUserParameterFromJSON,
    GetUserUserParameterToJSON,
    GuestLogin200ResponseFromJSON,
    GuestLogin200ResponseToJSON,
    GuestLogin500ResponseFromJSON,
    GuestLogin500ResponseToJSON,
    Login200ResponseFromJSON,
    Login200ResponseToJSON,
    Login202ResponseFromJSON,
    Login202ResponseToJSON,
    Login400ResponseFromJSON,
    Login400ResponseToJSON,
    LoginOtp200ResponseFromJSON,
    LoginOtp200ResponseToJSON,
    LoginOtp400ResponseFromJSON,
    LoginOtp400ResponseToJSON,
    LoginOtp401ResponseFromJSON,
    LoginOtp401ResponseToJSON,
    LoginOtp408ResponseFromJSON,
    LoginOtp408ResponseToJSON,
    LoginOtp500ResponseFromJSON,
    LoginOtp500ResponseToJSON,
    LoginOtpRequestFromJSON,
    LoginOtpRequestToJSON,
    LoginRequestFromJSON,
    LoginRequestToJSON,
    Logout200ResponseFromJSON,
    Logout200ResponseToJSON,
    ProviderList200ResponseFromJSON,
    ProviderList200ResponseToJSON,
    Signin200ResponseFromJSON,
    Signin200ResponseToJSON,
    Signin400ResponseFromJSON,
    Signin400ResponseToJSON,
    Signin500ResponseFromJSON,
    Signin500ResponseToJSON,
    StatusOtp200ResponseFromJSON,
    StatusOtp200ResponseToJSON,
    StatusOtp401ResponseFromJSON,
    StatusOtp401ResponseToJSON,
    StatusOtp500ResponseFromJSON,
    StatusOtp500ResponseToJSON,
} from '../models/index';

export interface GetUserRequest {
    user: GetUserUserParameter;
}

export interface LoginOperationRequest {
    loginRequest: LoginRequest;
}

export interface LoginOtpOperationRequest {
    loginOtpRequest: LoginOtpRequest;
}

export interface SigninRequest {
    loginRequest: LoginRequest;
}

/**
 * 
 */
export class OpenapiOtherApi extends runtime.BaseAPI {

    /**
     */
    async apiChatSocketIoGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/chat/socket.io`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // No body response for status 200
            return new runtime.VoidApiResponse(response);
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200`);
    }

    /**
     */
    async apiChatSocketIoGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiChatSocketIoGetRaw(initOverrides);
    }

    /**
     */
    async chatTestRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatTest200Response | StatusOtp401Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/chat/test`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => ChatTest200ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => StatusOtp401ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 401`);
    }

    /**
     */
    async chatTest(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatTest200Response | StatusOtp401Response> {
        const response = await this.chatTestRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async disableOtpRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DisableOtp200Response | DisableOtp401Response | DisableOtp500Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/auth/disableOtp`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => DisableOtp200ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => DisableOtp401ResponseFromJSON(jsonValue));
        }
        if (response.status === 500) {
            // Object response for status 500
            return new runtime.JSONApiResponse(response, (jsonValue) => DisableOtp500ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 401, 500`);
    }

    /**
     */
    async disableOtp(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DisableOtp200Response | DisableOtp401Response | DisableOtp500Response> {
        const response = await this.disableOtpRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async enableOtpRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnableOtp200Response | EnableOtp401Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/auth/enableOtp`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => EnableOtp200ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => EnableOtp401ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 401`);
    }

    /**
     */
    async enableOtp(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnableOtp200Response | EnableOtp401Response> {
        const response = await this.enableOtpRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getUserRaw(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetUser200Response | StatusOtp401Response | GetUser403Response | GetUser404Response>> {
        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling getUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/user/info/{user}`;
        urlPath = urlPath.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => GetUser200ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => StatusOtp401ResponseFromJSON(jsonValue));
        }
        if (response.status === 403) {
            // Object response for status 403
            return new runtime.JSONApiResponse(response, (jsonValue) => GetUser403ResponseFromJSON(jsonValue));
        }
        if (response.status === 404) {
            // Object response for status 404
            return new runtime.JSONApiResponse(response, (jsonValue) => GetUser404ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 401, 403, 404`);
    }

    /**
     */
    async getUser(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetUser200Response | StatusOtp401Response | GetUser403Response | GetUser404Response> {
        const response = await this.getUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async guestLoginRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GuestLogin200Response | GuestLogin500Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/auth/guest`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => GuestLogin200ResponseFromJSON(jsonValue));
        }
        if (response.status === 500) {
            // Object response for status 500
            return new runtime.JSONApiResponse(response, (jsonValue) => GuestLogin500ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 500`);
    }

    /**
     */
    async guestLogin(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GuestLogin200Response | GuestLogin500Response> {
        const response = await this.guestLoginRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async loginRaw(requestParameters: LoginOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Login200Response | Login202Response | Login400Response>> {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError(
                'loginRequest',
                'Required parameter "loginRequest" was null or undefined when calling login().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/auth/login`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => Login200ResponseFromJSON(jsonValue));
        }
        if (response.status === 202) {
            // Object response for status 202
            return new runtime.JSONApiResponse(response, (jsonValue) => Login202ResponseFromJSON(jsonValue));
        }
        if (response.status === 400) {
            // Object response for status 400
            return new runtime.JSONApiResponse(response, (jsonValue) => Login400ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 202, 400`);
    }

    /**
     */
    async login(requestParameters: LoginOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Login200Response | Login202Response | Login400Response> {
        const response = await this.loginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async loginOtpRaw(requestParameters: LoginOtpOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoginOtp200Response | LoginOtp400Response | LoginOtp401Response | LoginOtp408Response | LoginOtp500Response>> {
        if (requestParameters['loginOtpRequest'] == null) {
            throw new runtime.RequiredError(
                'loginOtpRequest',
                'Required parameter "loginOtpRequest" was null or undefined when calling loginOtp().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/auth/otp`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginOtpRequestToJSON(requestParameters['loginOtpRequest']),
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => LoginOtp200ResponseFromJSON(jsonValue));
        }
        if (response.status === 400) {
            // Object response for status 400
            return new runtime.JSONApiResponse(response, (jsonValue) => LoginOtp400ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => LoginOtp401ResponseFromJSON(jsonValue));
        }
        if (response.status === 408) {
            // Object response for status 408
            return new runtime.JSONApiResponse(response, (jsonValue) => LoginOtp408ResponseFromJSON(jsonValue));
        }
        if (response.status === 500) {
            // Object response for status 500
            return new runtime.JSONApiResponse(response, (jsonValue) => LoginOtp500ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 400, 401, 408, 500`);
    }

    /**
     */
    async loginOtp(requestParameters: LoginOtpOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoginOtp200Response | LoginOtp400Response | LoginOtp401Response | LoginOtp408Response | LoginOtp500Response> {
        const response = await this.loginOtpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async logoutRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Logout200Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/auth/logout`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => Logout200ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200`);
    }

    /**
     */
    async logout(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Logout200Response> {
        const response = await this.logoutRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async providerListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProviderList200Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/auth/providerList`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => ProviderList200ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200`);
    }

    /**
     */
    async providerList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProviderList200Response> {
        const response = await this.providerListRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async signinRaw(requestParameters: SigninRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Signin200Response | Signin400Response | Signin500Response>> {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError(
                'loginRequest',
                'Required parameter "loginRequest" was null or undefined when calling signin().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/auth/signin`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => Signin200ResponseFromJSON(jsonValue));
        }
        if (response.status === 400) {
            // Object response for status 400
            return new runtime.JSONApiResponse(response, (jsonValue) => Signin400ResponseFromJSON(jsonValue));
        }
        if (response.status === 500) {
            // Object response for status 500
            return new runtime.JSONApiResponse(response, (jsonValue) => Signin500ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 400, 500`);
    }

    /**
     */
    async signin(requestParameters: SigninRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Signin200Response | Signin400Response | Signin500Response> {
        const response = await this.signinRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async statusOtpRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StatusOtp200Response | StatusOtp401Response | StatusOtp500Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/auth/statusOtp`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => StatusOtp200ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => StatusOtp401ResponseFromJSON(jsonValue));
        }
        if (response.status === 500) {
            // Object response for status 500
            return new runtime.JSONApiResponse(response, (jsonValue) => StatusOtp500ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 401, 500`);
    }

    /**
     */
    async statusOtp(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StatusOtp200Response | StatusOtp401Response | StatusOtp500Response> {
        const response = await this.statusOtpRaw(initOverrides);
        return await response.value();
    }

}
