/* tslint:disable */
/* eslint-disable */
/**
 * @fastify/swagger
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 9.6.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AllowGuestMessage200Response,
  AllowGuestMessage403Response,
  ChangeDesc200Response,
  ChangeDesc400Response,
  ChangeDesc403Response,
  ChangeDescRequest,
  ChangeDisplayName200Response,
  ChangeDisplayName400Response,
  ChangeDisplayNameRequest,
  ChangePassword200Response,
  ChangePassword400Response,
  ChangePassword401Response,
  ChangePassword500Response,
  ChangePasswordRequest,
  CreatePauseGame200Response,
  CreatePauseGame404Response,
  CreatePauseGameRequest,
  DisableOtp200Response,
  DisableOtp400Response,
  DisableOtp500Response,
  EnableOtp200Response,
  EnableOtp400Response,
  EnableOtp401Response,
  GetUser200Response,
  GetUser403Response,
  GetUser404Response,
  GetUserUserParameter,
  GuestLogin200Response,
  GuestLogin400Response,
  GuestLogin500Response,
  GuestLoginRequest,
  Login200Response,
  Login202Response,
  Login400Response,
  LoginOtp200Response,
  LoginOtp400Response,
  LoginOtp401Response,
  LoginOtp408Response,
  LoginOtp500Response,
  LoginOtpRequest,
  LoginRequest,
  Logout200Response,
  PongHistory200Response,
  PongHistory404Response,
  ProviderList200Response,
  Signin200Response,
  Signin400Response,
  Signin500Response,
  StatusOtp200Response,
  StatusOtp401Response,
  StatusOtp500Response,
  TournamentData200Response,
  TournamentData404Response,
  TournamentList200Response,
  TournamentList404Response,
  TttHistory200Response,
  TttHistory404Response,
} from '../models/index';
import {
    AllowGuestMessage200ResponseFromJSON,
    AllowGuestMessage200ResponseToJSON,
    AllowGuestMessage403ResponseFromJSON,
    AllowGuestMessage403ResponseToJSON,
    ChangeDesc200ResponseFromJSON,
    ChangeDesc200ResponseToJSON,
    ChangeDesc400ResponseFromJSON,
    ChangeDesc400ResponseToJSON,
    ChangeDesc403ResponseFromJSON,
    ChangeDesc403ResponseToJSON,
    ChangeDescRequestFromJSON,
    ChangeDescRequestToJSON,
    ChangeDisplayName200ResponseFromJSON,
    ChangeDisplayName200ResponseToJSON,
    ChangeDisplayName400ResponseFromJSON,
    ChangeDisplayName400ResponseToJSON,
    ChangeDisplayNameRequestFromJSON,
    ChangeDisplayNameRequestToJSON,
    ChangePassword200ResponseFromJSON,
    ChangePassword200ResponseToJSON,
    ChangePassword400ResponseFromJSON,
    ChangePassword400ResponseToJSON,
    ChangePassword401ResponseFromJSON,
    ChangePassword401ResponseToJSON,
    ChangePassword500ResponseFromJSON,
    ChangePassword500ResponseToJSON,
    ChangePasswordRequestFromJSON,
    ChangePasswordRequestToJSON,
    CreatePauseGame200ResponseFromJSON,
    CreatePauseGame200ResponseToJSON,
    CreatePauseGame404ResponseFromJSON,
    CreatePauseGame404ResponseToJSON,
    CreatePauseGameRequestFromJSON,
    CreatePauseGameRequestToJSON,
    DisableOtp200ResponseFromJSON,
    DisableOtp200ResponseToJSON,
    DisableOtp400ResponseFromJSON,
    DisableOtp400ResponseToJSON,
    DisableOtp500ResponseFromJSON,
    DisableOtp500ResponseToJSON,
    EnableOtp200ResponseFromJSON,
    EnableOtp200ResponseToJSON,
    EnableOtp400ResponseFromJSON,
    EnableOtp400ResponseToJSON,
    EnableOtp401ResponseFromJSON,
    EnableOtp401ResponseToJSON,
    GetUser200ResponseFromJSON,
    GetUser200ResponseToJSON,
    GetUser403ResponseFromJSON,
    GetUser403ResponseToJSON,
    GetUser404ResponseFromJSON,
    GetUser404ResponseToJSON,
    GetUserUserParameterFromJSON,
    GetUserUserParameterToJSON,
    GuestLogin200ResponseFromJSON,
    GuestLogin200ResponseToJSON,
    GuestLogin400ResponseFromJSON,
    GuestLogin400ResponseToJSON,
    GuestLogin500ResponseFromJSON,
    GuestLogin500ResponseToJSON,
    GuestLoginRequestFromJSON,
    GuestLoginRequestToJSON,
    Login200ResponseFromJSON,
    Login200ResponseToJSON,
    Login202ResponseFromJSON,
    Login202ResponseToJSON,
    Login400ResponseFromJSON,
    Login400ResponseToJSON,
    LoginOtp200ResponseFromJSON,
    LoginOtp200ResponseToJSON,
    LoginOtp400ResponseFromJSON,
    LoginOtp400ResponseToJSON,
    LoginOtp401ResponseFromJSON,
    LoginOtp401ResponseToJSON,
    LoginOtp408ResponseFromJSON,
    LoginOtp408ResponseToJSON,
    LoginOtp500ResponseFromJSON,
    LoginOtp500ResponseToJSON,
    LoginOtpRequestFromJSON,
    LoginOtpRequestToJSON,
    LoginRequestFromJSON,
    LoginRequestToJSON,
    Logout200ResponseFromJSON,
    Logout200ResponseToJSON,
    PongHistory200ResponseFromJSON,
    PongHistory200ResponseToJSON,
    PongHistory404ResponseFromJSON,
    PongHistory404ResponseToJSON,
    ProviderList200ResponseFromJSON,
    ProviderList200ResponseToJSON,
    Signin200ResponseFromJSON,
    Signin200ResponseToJSON,
    Signin400ResponseFromJSON,
    Signin400ResponseToJSON,
    Signin500ResponseFromJSON,
    Signin500ResponseToJSON,
    StatusOtp200ResponseFromJSON,
    StatusOtp200ResponseToJSON,
    StatusOtp401ResponseFromJSON,
    StatusOtp401ResponseToJSON,
    StatusOtp500ResponseFromJSON,
    StatusOtp500ResponseToJSON,
    TournamentData200ResponseFromJSON,
    TournamentData200ResponseToJSON,
    TournamentData404ResponseFromJSON,
    TournamentData404ResponseToJSON,
    TournamentList200ResponseFromJSON,
    TournamentList200ResponseToJSON,
    TournamentList404ResponseFromJSON,
    TournamentList404ResponseToJSON,
    TttHistory200ResponseFromJSON,
    TttHistory200ResponseToJSON,
    TttHistory404ResponseFromJSON,
    TttHistory404ResponseToJSON,
} from '../models/index';

export interface ChangeDescOperationRequest {
    changeDescRequest: ChangeDescRequest;
}

export interface ChangeDisplayNameOperationRequest {
    changeDisplayNameRequest: ChangeDisplayNameRequest;
}

export interface ChangePasswordOperationRequest {
    changePasswordRequest: ChangePasswordRequest;
}

export interface CreatePauseGameOperationRequest {
    createPauseGameRequest: CreatePauseGameRequest;
}

export interface GetUserRequest {
    user: GetUserUserParameter;
}

export interface GuestLoginOperationRequest {
    guestLoginRequest?: GuestLoginRequest;
}

export interface LoginOperationRequest {
    loginRequest: LoginRequest;
}

export interface LoginOtpOperationRequest {
    loginOtpRequest: LoginOtpRequest;
}

export interface PongHistoryRequest {
    user: string;
}

export interface SigninRequest {
    loginRequest: LoginRequest;
}

export interface TournamentDataRequest {
    id: string;
}

export interface TttHistoryRequest {
    user: string;
}

/**
 * 
 */
export class OpenapiOtherApi extends runtime.BaseAPI {

    /**
     */
    async allowGuestMessageRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AllowGuestMessage200Response | StatusOtp401Response | AllowGuestMessage403Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/user/allowGuestMessage`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => AllowGuestMessage200ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => StatusOtp401ResponseFromJSON(jsonValue));
        }
        if (response.status === 403) {
            // Object response for status 403
            return new runtime.JSONApiResponse(response, (jsonValue) => AllowGuestMessage403ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 401, 403`);
    }

    /**
     */
    async allowGuestMessage(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AllowGuestMessage200Response | StatusOtp401Response | AllowGuestMessage403Response> {
        const response = await this.allowGuestMessageRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async changeDescRaw(requestParameters: ChangeDescOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChangeDesc200Response | ChangeDesc400Response | ChangePassword401Response | ChangeDesc403Response>> {
        if (requestParameters['changeDescRequest'] == null) {
            throw new runtime.RequiredError(
                'changeDescRequest',
                'Required parameter "changeDescRequest" was null or undefined when calling changeDesc().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/user/changeDesc`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ChangeDescRequestToJSON(requestParameters['changeDescRequest']),
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => ChangeDesc200ResponseFromJSON(jsonValue));
        }
        if (response.status === 400) {
            // Object response for status 400
            return new runtime.JSONApiResponse(response, (jsonValue) => ChangeDesc400ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => ChangePassword401ResponseFromJSON(jsonValue));
        }
        if (response.status === 403) {
            // Object response for status 403
            return new runtime.JSONApiResponse(response, (jsonValue) => ChangeDesc403ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 400, 401, 403`);
    }

    /**
     */
    async changeDesc(requestParameters: ChangeDescOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChangeDesc200Response | ChangeDesc400Response | ChangePassword401Response | ChangeDesc403Response> {
        const response = await this.changeDescRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async changeDisplayNameRaw(requestParameters: ChangeDisplayNameOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChangeDisplayName200Response | ChangeDisplayName400Response | ChangePassword401Response>> {
        if (requestParameters['changeDisplayNameRequest'] == null) {
            throw new runtime.RequiredError(
                'changeDisplayNameRequest',
                'Required parameter "changeDisplayNameRequest" was null or undefined when calling changeDisplayName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/user/changeDisplayName`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ChangeDisplayNameRequestToJSON(requestParameters['changeDisplayNameRequest']),
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => ChangeDisplayName200ResponseFromJSON(jsonValue));
        }
        if (response.status === 400) {
            // Object response for status 400
            return new runtime.JSONApiResponse(response, (jsonValue) => ChangeDisplayName400ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => ChangePassword401ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 400, 401`);
    }

    /**
     */
    async changeDisplayName(requestParameters: ChangeDisplayNameOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChangeDisplayName200Response | ChangeDisplayName400Response | ChangePassword401Response> {
        const response = await this.changeDisplayNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async changePasswordRaw(requestParameters: ChangePasswordOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChangePassword200Response | ChangePassword400Response | ChangePassword401Response | ChangePassword500Response>> {
        if (requestParameters['changePasswordRequest'] == null) {
            throw new runtime.RequiredError(
                'changePasswordRequest',
                'Required parameter "changePasswordRequest" was null or undefined when calling changePassword().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/auth/changePassword`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ChangePasswordRequestToJSON(requestParameters['changePasswordRequest']),
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => ChangePassword200ResponseFromJSON(jsonValue));
        }
        if (response.status === 400) {
            // Object response for status 400
            return new runtime.JSONApiResponse(response, (jsonValue) => ChangePassword400ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => ChangePassword401ResponseFromJSON(jsonValue));
        }
        if (response.status === 500) {
            // Object response for status 500
            return new runtime.JSONApiResponse(response, (jsonValue) => ChangePassword500ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 400, 401, 500`);
    }

    /**
     */
    async changePassword(requestParameters: ChangePasswordOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChangePassword200Response | ChangePassword400Response | ChangePassword401Response | ChangePassword500Response> {
        const response = await this.changePasswordRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async createPauseGameRaw(requestParameters: CreatePauseGameOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatePauseGame200Response | CreatePauseGame404Response>> {
        if (requestParameters['createPauseGameRequest'] == null) {
            throw new runtime.RequiredError(
                'createPauseGameRequest',
                'Required parameter "createPauseGameRequest" was null or undefined when calling createPauseGame().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/pong/createPausedGame`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreatePauseGameRequestToJSON(requestParameters['createPauseGameRequest']),
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => CreatePauseGame200ResponseFromJSON(jsonValue));
        }
        if (response.status === 404) {
            // Object response for status 404
            return new runtime.JSONApiResponse(response, (jsonValue) => CreatePauseGame404ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 404`);
    }

    /**
     */
    async createPauseGame(requestParameters: CreatePauseGameOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatePauseGame200Response | CreatePauseGame404Response> {
        const response = await this.createPauseGameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async denyGuestMessageRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AllowGuestMessage200Response | StatusOtp401Response | AllowGuestMessage403Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/user/denyGuestMessage`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => AllowGuestMessage200ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => StatusOtp401ResponseFromJSON(jsonValue));
        }
        if (response.status === 403) {
            // Object response for status 403
            return new runtime.JSONApiResponse(response, (jsonValue) => AllowGuestMessage403ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 401, 403`);
    }

    /**
     */
    async denyGuestMessage(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AllowGuestMessage200Response | StatusOtp401Response | AllowGuestMessage403Response> {
        const response = await this.denyGuestMessageRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async disableOtpRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DisableOtp200Response | DisableOtp400Response | ChangePassword401Response | DisableOtp500Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/auth/disableOtp`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => DisableOtp200ResponseFromJSON(jsonValue));
        }
        if (response.status === 400) {
            // Object response for status 400
            return new runtime.JSONApiResponse(response, (jsonValue) => DisableOtp400ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => ChangePassword401ResponseFromJSON(jsonValue));
        }
        if (response.status === 500) {
            // Object response for status 500
            return new runtime.JSONApiResponse(response, (jsonValue) => DisableOtp500ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 400, 401, 500`);
    }

    /**
     */
    async disableOtp(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DisableOtp200Response | DisableOtp400Response | ChangePassword401Response | DisableOtp500Response> {
        const response = await this.disableOtpRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async enableOtpRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnableOtp200Response | EnableOtp400Response | EnableOtp401Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/auth/enableOtp`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => EnableOtp200ResponseFromJSON(jsonValue));
        }
        if (response.status === 400) {
            // Object response for status 400
            return new runtime.JSONApiResponse(response, (jsonValue) => EnableOtp400ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => EnableOtp401ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 400, 401`);
    }

    /**
     */
    async enableOtp(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnableOtp200Response | EnableOtp400Response | EnableOtp401Response> {
        const response = await this.enableOtpRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getUserRaw(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetUser200Response | StatusOtp401Response | GetUser403Response | GetUser404Response>> {
        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling getUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/user/info/{user}`;
        urlPath = urlPath.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => GetUser200ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => StatusOtp401ResponseFromJSON(jsonValue));
        }
        if (response.status === 403) {
            // Object response for status 403
            return new runtime.JSONApiResponse(response, (jsonValue) => GetUser403ResponseFromJSON(jsonValue));
        }
        if (response.status === 404) {
            // Object response for status 404
            return new runtime.JSONApiResponse(response, (jsonValue) => GetUser404ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 401, 403, 404`);
    }

    /**
     */
    async getUser(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetUser200Response | StatusOtp401Response | GetUser403Response | GetUser404Response> {
        const response = await this.getUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async guestLoginRaw(requestParameters: GuestLoginOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GuestLogin200Response | GuestLogin400Response | GuestLogin500Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/auth/guest`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GuestLoginRequestToJSON(requestParameters['guestLoginRequest']),
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => GuestLogin200ResponseFromJSON(jsonValue));
        }
        if (response.status === 400) {
            // Object response for status 400
            return new runtime.JSONApiResponse(response, (jsonValue) => GuestLogin400ResponseFromJSON(jsonValue));
        }
        if (response.status === 500) {
            // Object response for status 500
            return new runtime.JSONApiResponse(response, (jsonValue) => GuestLogin500ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 400, 500`);
    }

    /**
     */
    async guestLogin(requestParameters: GuestLoginOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GuestLogin200Response | GuestLogin400Response | GuestLogin500Response> {
        const response = await this.guestLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async loginRaw(requestParameters: LoginOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Login200Response | Login202Response | Login400Response>> {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError(
                'loginRequest',
                'Required parameter "loginRequest" was null or undefined when calling login().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/auth/login`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => Login200ResponseFromJSON(jsonValue));
        }
        if (response.status === 202) {
            // Object response for status 202
            return new runtime.JSONApiResponse(response, (jsonValue) => Login202ResponseFromJSON(jsonValue));
        }
        if (response.status === 400) {
            // Object response for status 400
            return new runtime.JSONApiResponse(response, (jsonValue) => Login400ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 202, 400`);
    }

    /**
     */
    async login(requestParameters: LoginOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Login200Response | Login202Response | Login400Response> {
        const response = await this.loginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async loginOtpRaw(requestParameters: LoginOtpOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoginOtp200Response | LoginOtp400Response | LoginOtp401Response | LoginOtp408Response | LoginOtp500Response>> {
        if (requestParameters['loginOtpRequest'] == null) {
            throw new runtime.RequiredError(
                'loginOtpRequest',
                'Required parameter "loginOtpRequest" was null or undefined when calling loginOtp().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/auth/otp`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginOtpRequestToJSON(requestParameters['loginOtpRequest']),
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => LoginOtp200ResponseFromJSON(jsonValue));
        }
        if (response.status === 400) {
            // Object response for status 400
            return new runtime.JSONApiResponse(response, (jsonValue) => LoginOtp400ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => LoginOtp401ResponseFromJSON(jsonValue));
        }
        if (response.status === 408) {
            // Object response for status 408
            return new runtime.JSONApiResponse(response, (jsonValue) => LoginOtp408ResponseFromJSON(jsonValue));
        }
        if (response.status === 500) {
            // Object response for status 500
            return new runtime.JSONApiResponse(response, (jsonValue) => LoginOtp500ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 400, 401, 408, 500`);
    }

    /**
     */
    async loginOtp(requestParameters: LoginOtpOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoginOtp200Response | LoginOtp400Response | LoginOtp401Response | LoginOtp408Response | LoginOtp500Response> {
        const response = await this.loginOtpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async logoutRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Logout200Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/auth/logout`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => Logout200ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200`);
    }

    /**
     */
    async logout(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Logout200Response> {
        const response = await this.logoutRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async pongHistoryRaw(requestParameters: PongHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PongHistory200Response | StatusOtp401Response | PongHistory404Response>> {
        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling pongHistory().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/pong/history/{user}`;
        urlPath = urlPath.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => PongHistory200ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => StatusOtp401ResponseFromJSON(jsonValue));
        }
        if (response.status === 404) {
            // Object response for status 404
            return new runtime.JSONApiResponse(response, (jsonValue) => PongHistory404ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 401, 404`);
    }

    /**
     */
    async pongHistory(requestParameters: PongHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PongHistory200Response | StatusOtp401Response | PongHistory404Response> {
        const response = await this.pongHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async providerListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProviderList200Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/auth/providerList`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => ProviderList200ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200`);
    }

    /**
     */
    async providerList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProviderList200Response> {
        const response = await this.providerListRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async signinRaw(requestParameters: SigninRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Signin200Response | Signin400Response | Signin500Response>> {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError(
                'loginRequest',
                'Required parameter "loginRequest" was null or undefined when calling signin().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/auth/signin`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => Signin200ResponseFromJSON(jsonValue));
        }
        if (response.status === 400) {
            // Object response for status 400
            return new runtime.JSONApiResponse(response, (jsonValue) => Signin400ResponseFromJSON(jsonValue));
        }
        if (response.status === 500) {
            // Object response for status 500
            return new runtime.JSONApiResponse(response, (jsonValue) => Signin500ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 400, 500`);
    }

    /**
     */
    async signin(requestParameters: SigninRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Signin200Response | Signin400Response | Signin500Response> {
        const response = await this.signinRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async statusOtpRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StatusOtp200Response | StatusOtp401Response | StatusOtp500Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/auth/statusOtp`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => StatusOtp200ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => StatusOtp401ResponseFromJSON(jsonValue));
        }
        if (response.status === 500) {
            // Object response for status 500
            return new runtime.JSONApiResponse(response, (jsonValue) => StatusOtp500ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 401, 500`);
    }

    /**
     */
    async statusOtp(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StatusOtp200Response | StatusOtp401Response | StatusOtp500Response> {
        const response = await this.statusOtpRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async tournamentDataRaw(requestParameters: TournamentDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TournamentData200Response | StatusOtp401Response | TournamentData404Response>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling tournamentData().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/pong/tournament/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => TournamentData200ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => StatusOtp401ResponseFromJSON(jsonValue));
        }
        if (response.status === 404) {
            // Object response for status 404
            return new runtime.JSONApiResponse(response, (jsonValue) => TournamentData404ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 401, 404`);
    }

    /**
     */
    async tournamentData(requestParameters: TournamentDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TournamentData200Response | StatusOtp401Response | TournamentData404Response> {
        const response = await this.tournamentDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async tournamentListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TournamentList200Response | StatusOtp401Response | TournamentList404Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/pong/tournament/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => TournamentList200ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => StatusOtp401ResponseFromJSON(jsonValue));
        }
        if (response.status === 404) {
            // Object response for status 404
            return new runtime.JSONApiResponse(response, (jsonValue) => TournamentList404ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 401, 404`);
    }

    /**
     */
    async tournamentList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TournamentList200Response | StatusOtp401Response | TournamentList404Response> {
        const response = await this.tournamentListRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async tttHistoryRaw(requestParameters: TttHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TttHistory200Response | StatusOtp401Response | TttHistory404Response>> {
        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling tttHistory().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/ttt/history/{user}`;
        urlPath = urlPath.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        // CHANGED: Handle all status codes defined in the OpenAPI spec, not just 2xx responses
        // This allows typed access to error responses (4xx, 5xx) and other status codes.
        // The code routes responses based on the actual HTTP status code and returns
        // appropriately typed ApiResponse wrappers for each status code.
        if (response.status === 200) {
            // Object response for status 200
            return new runtime.JSONApiResponse(response, (jsonValue) => TttHistory200ResponseFromJSON(jsonValue));
        }
        if (response.status === 401) {
            // Object response for status 401
            return new runtime.JSONApiResponse(response, (jsonValue) => StatusOtp401ResponseFromJSON(jsonValue));
        }
        if (response.status === 404) {
            // Object response for status 404
            return new runtime.JSONApiResponse(response, (jsonValue) => TttHistory404ResponseFromJSON(jsonValue));
        }
        // CHANGED: Throw error if status code is not handled by any of the defined responses
        // This ensures all code paths return a value and provides clear error messages for unexpected status codes
        // Only throw if responses were defined but none matched the actual status code
        throw new runtime.ResponseError(response, `Unexpected status code: ${response.status}. Expected one of: 200, 401, 404`);
    }

    /**
     */
    async tttHistory(requestParameters: TttHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TttHistory200Response | StatusOtp401Response | TttHistory404Response> {
        const response = await this.tttHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
